CCS PCM C Compiler, Version 4.120, 31882               06-oct.-18 22:45

               Filename: C:\Users\Public\Apoyos\DiseñoMecatrónico\PIC16F1823\E-SDigitales\I2C_Master.lst

               ROM used: 271 words (13%)
                         Largest free fragment is 1777
               RAM used: 9 (7%) at main() level
                         29 (23%) worst case
               Stack:    2 locations

*
0000:  MOVLP  00
0001:  GOTO   0C2
0002:  NOP
.................... /* 
....................    Código fuente para Maestro de I2C 
.................... */ 
.................... #include <16F1823.h> 
.................... //////// Standard Header file for the PIC16F1823 device //////////////// 
.................... #device PIC16F1823 
.................... #list 
....................  
....................  
.................... #fuses NOWDT, NOMCLR, PUT 
.................... #use delay (int = 32 MHz) 
*
001D:  MOVLW  20
001E:  MOVWF  05
001F:  MOVLW  08
0020:  MOVWF  04
0021:  MOVF   00,W
0022:  BTFSC  03.2
0023:  GOTO   031
0024:  MOVLW  0A
0025:  MOVWF  21
0026:  CLRF   20
0027:  DECFSZ 20,F
0028:  GOTO   027
0029:  DECFSZ 21,F
002A:  GOTO   026
002B:  MOVLW  5F
002C:  MOVWF  20
002D:  DECFSZ 20,F
002E:  GOTO   02D
002F:  DECFSZ 00,F
0030:  GOTO   024
0031:  RETURN
.................... #use RS232(baud = 9600, XMIT = pin_c4, RCV = pin_c5) 
*
004B:  MOVLB  01
004C:  BCF    0E.4
004D:  MOVLB  02
004E:  BCF    0E.4
004F:  MOVLW  08
0050:  MOVLB  00
0051:  MOVWF  21
0052:  GOTO   053
0053:  NOP
0054:  BSF    21.7
0055:  GOTO   068
0056:  BCF    21.7
0057:  RRF    2C,F
0058:  MOVLB  02
0059:  BTFSC  03.0
005A:  BSF    0E.4
005B:  BTFSS  03.0
005C:  BCF    0E.4
005D:  MOVLB  00
005E:  BSF    21.6
005F:  GOTO   068
0060:  BCF    21.6
0061:  DECFSZ 21,F
0062:  GOTO   057
0063:  GOTO   064
0064:  NOP
0065:  MOVLB  02
0066:  BSF    0E.4
0067:  MOVLB  00
0068:  MOVLW  01
0069:  MOVWF  20
006A:  CLRF   04
006B:  DECFSZ 04,F
006C:  GOTO   06B
006D:  DECFSZ 20,F
006E:  GOTO   06A
006F:  MOVLW  0D
0070:  MOVWF  04
0071:  DECFSZ 04,F
0072:  GOTO   071
0073:  GOTO   074
0074:  BTFSC  21.7
0075:  GOTO   056
0076:  BTFSC  21.6
0077:  GOTO   060
0078:  RETURN
.................... #use I2C(Master, SDA = pin_c1, SCL = pin_c0, FORCE_HW, STREAM = Master) // Maestro-esclavo 
*
0008:  MOVLB  04
0009:  BCF    15.7
000A:  MOVLB  00
000B:  BCF    11.3
000C:  MOVF   28,W
000D:  MOVLB  04
000E:  MOVWF  11
000F:  MOVLW  02
0010:  BTFSC  15.7
0011:  GOTO   019
0012:  MOVLB  00
0013:  BTFSS  11.3
0014:  GOTO   013
0015:  MOVLW  00
0016:  MOVLB  04
0017:  BTFSC  16.6
0018:  MOVLW  01
0019:  MOVLB  00
001A:  MOVWF  21
001B:  MOVLP  00
001C:  GOTO   0EB (RETURN)
*
0032:  MOVLB  04
0033:  BCF    15.6
0034:  BSF    16.3
0035:  BTFSC  16.3
0036:  GOTO   035
0037:  MOVLB  00
0038:  BTFSS  20.0
0039:  GOTO   03D
003A:  MOVLB  04
003B:  BCF    16.5
003C:  MOVLB  00
003D:  BTFSC  20.0
003E:  GOTO   042
003F:  MOVLB  04
0040:  BSF    16.5
0041:  MOVLB  00
0042:  MOVLB  04
0043:  BSF    16.4
0044:  BTFSC  16.4
0045:  GOTO   044
0046:  MOVF   11,W
0047:  MOVLB  00
0048:  MOVWF  21
0049:  MOVLP  00
004A:  GOTO   0F3 (RETURN)
.................... #define slv1_w 0x50  //byte 50 a slv1 : escribir 
.................... #define slv1_r 0x51  //byte 51 a slv1 : leer 
.................... #define slv2_w 0x60  //byte 60 a slv2 : escribir 
.................... #define slv2_r 0x61  //byte 61 a slv2 : leer 
....................  
.................... //Las direcciones 0xnn no deben exceder 7 bits (128 direcciones disponibles) 
.................... int b1 = 0, b2 = 0; 
.................... char s1 = 0, s2 = 0; 
....................  
....................  
.................... int main(void) { 
*
00C2:  CLRF   05
00C3:  CLRF   04
00C4:  MOVLW  1F
00C5:  ANDWF  03,F
00C6:  MOVLW  F4
00C7:  MOVLB  01
00C8:  MOVWF  19
00C9:  BCF    0E.4
00CA:  MOVLB  02
00CB:  BSF    0E.4
00CC:  MOVLB  01
00CD:  BSF    0E.0
00CE:  BSF    0E.1
00CF:  MOVLW  4F
00D0:  MOVLB  04
00D1:  MOVWF  12
00D2:  MOVLW  28
00D3:  MOVWF  15
00D4:  BSF    14.7
00D5:  BCF    14.6
00D6:  MOVLB  00
00D7:  CLRF   24
00D8:  CLRF   25
00D9:  CLRF   26
00DA:  CLRF   27
00DB:  MOVLB  03
00DC:  CLRF   0C
00DD:  CLRF   0E
00DE:  MOVLB  02
00DF:  CLRF   12
00E0:  CLRF   11
00E1:  CLRF   14
00E2:  CLRF   13
....................    while(true) { 
....................       I2C_start(Master);   // Iniciar stream-comunicacion 
00E3:  MOVLB  04
00E4:  BSF    16.0
00E5:  BTFSC  16.0
00E6:  GOTO   0E5
....................       b1 = I2C_WRITE(Master, slv1_r);  // Master escribirá a partir de la lectura de slv1 
00E7:  MOVLW  51
00E8:  MOVLB  00
00E9:  MOVWF  28
00EA:  GOTO   008
00EB:  MOVF   21,W
00EC:  MOVWF  24
....................       delay_ms(100); 
00ED:  MOVLW  64
00EE:  MOVWF  28
00EF:  CALL   01D
....................       s1 = I2C_READ(slv1_r);        // Si se pone 1 aún espera datos, con 0 la lectura está terminada 
00F0:  MOVLW  51
00F1:  MOVWF  20
00F2:  GOTO   032
00F3:  MOVF   21,W
00F4:  MOVWF  26
....................       delay_ms(100); 
00F5:  MOVLW  64
00F6:  MOVWF  28
00F7:  CALL   01D
....................       I2C_STOP(Master); 
00F8:  MOVLB  04
00F9:  BSF    16.2
00FA:  BTFSC  16.2
00FB:  GOTO   0FA
....................       printf("Dato: %c", s1); 
00FC:  MOVLW  03
00FD:  MOVLB  03
00FE:  MOVWF  11
00FF:  MOVLW  00
0100:  MOVWF  12
0101:  BCF    03.0
0102:  MOVLW  06
0103:  MOVLB  00
0104:  MOVWF  28
0105:  GOTO   079
0106:  MOVF   26,W
0107:  MOVWF  2C
0108:  CALL   04B
....................    } 
0109:  MOVLB  02
010A:  GOTO   0E3
....................  
....................    return 0; 
010B:  MOVLW  00
010C:  MOVLB  00
010D:  MOVWF  21
.................... } 
010E:  SLEEP

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
