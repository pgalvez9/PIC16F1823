CCS PCM C Compiler, Version 4.120, 31882               07-oct.-18 23:50

               Filename: C:\Users\Public\Apoyos\DiseñoMecatrónico\PIC16F1823\Tareas\ControlMotores\ControlMotores.lst

               ROM used: 184 words (9%)
                         Largest free fragment is 1864
               RAM used: 8 (6%) at main() level
                         23 (18%) worst case
               Stack:    1 locations

*
0000:  MOVLP  00
0001:  GOTO   077
0002:  NOP
.................... #include <16F1823.H> 
.................... //////// Standard Header file for the PIC16F1823 device //////////////// 
.................... #device PIC16F1823 
.................... #list 
....................  
.................... #use fast_IO(A) 
.................... #use fast_IO(C) 
.................... #fuses PUT, NOWDT, NOMCLR 
....................  
.................... #use delay(int = 32 MHz) 
.................... #BYTE TrisA = 0x08c 
.................... #BYTE TrisC = 0x08e 
.................... #byte PortA = 0x00c 
.................... #BYTE PortC = 0x00e 
....................  
....................    /* 
....................       bit_set(Port,x) 
....................       bit_clear(Port,x) 
....................       bit_test(Port,x) 
....................    */  
....................  
.................... // Pseudo interrupcion por software 
.................... boolean i_ant = False, j_ant = False, k_ant = False; 
.................... boolean motorSelector = false;   // false - DC motor, true - BiStepper Motor  
.................... boolean Sentido = false;   // false - izq, true - der 
.................... boolean intensidad = false;  // Define la intensidad del giro 
....................  
.................... int DC() { 
....................    if(motorSelector == False) { 
0003:  BTFSC  24.3
0004:  GOTO   00E
....................       bit_clear(PortC,2); 
0005:  BCF    0E.2
....................       bit_clear(PortC,3); 
0006:  BCF    0E.3
....................       if(Sentido) { 
0007:  BTFSS  24.4
0008:  GOTO   00C
....................          bit_clear(PortC,1); 
0009:  BCF    0E.1
....................          bit_set(PortC,0); 
000A:  BSF    0E.0
....................       } 
....................       else { 
000B:  GOTO   00E
....................          bit_clear(PortC,0); 
000C:  BCF    0E.0
....................          bit_set(PortC,1); 
000D:  BSF    0E.1
....................       } 
....................    } 
....................  
....................    return 0; 
000E:  MOVLW  00
000F:  MOVWF  21
.................... } 
0010:  MOVLP  00
0011:  GOTO   0B3 (RETURN)
....................  
.................... int BiStr() { 
....................    int u; 
....................    if(motorSelector == True) { 
0012:  BTFSS  24.3
0013:  GOTO   073
....................       bit_clear(PortC,0); 
0014:  BCF    0E.0
....................       bit_clear(PortC,1); 
0015:  BCF    0E.1
....................       if(Sentido == False) { 
0016:  BTFSC  24.4
0017:  GOTO   046
....................          for(u = 0; u < 4; u++) { 
0018:  CLRF   25
0019:  MOVF   25,W
001A:  SUBLW  03
001B:  BTFSS  03.0
001C:  GOTO   045
....................             bit_set(PortC,u+2); 
001D:  MOVLW  02
001E:  ADDWF  25,W
001F:  MOVWF  26
0020:  MOVLW  01
0021:  MOVWF  20
0022:  MOVF   26,W
0023:  MOVWF  21
0024:  BTFSC  03.2
0025:  GOTO   029
0026:  LSLF   20,F
0027:  DECFSZ 21,F
0028:  GOTO   026
0029:  MOVF   20,W
002A:  IORWF  0E,F
....................             bit_clear(PortC,u+1); 
002B:  MOVLW  01
002C:  ADDWF  25,W
002D:  MOVWF  26
002E:  MOVLW  01
002F:  MOVWF  20
0030:  MOVF   26,W
0031:  MOVWF  21
0032:  BTFSC  03.2
0033:  GOTO   037
0034:  LSLF   20,F
0035:  DECFSZ 21,F
0036:  GOTO   034
0037:  MOVF   20,W
0038:  XORLW  FF
0039:  ANDWF  0E,F
....................              
....................       i_ant = bit_test(PortA,0); 
003A:  BCF    24.0
003B:  BTFSC  0C.0
003C:  BSF    24.0
....................       j_ant = bit_test(PortA,1); 
003D:  BCF    24.1
003E:  BTFSC  0C.1
003F:  BSF    24.1
....................       k_ant = bit_test(PortA,2); 
0040:  BCF    24.2
0041:  BTFSC  0C.2
0042:  BSF    24.2
....................          } 
0043:  INCF   25,F
0044:  GOTO   019
....................       } 
....................       else { 
0045:  GOTO   073
....................          for(u = 4; u > 0; u--) { 
0046:  MOVLW  04
0047:  MOVWF  25
0048:  MOVF   25,F
0049:  BTFSC  03.2
004A:  GOTO   073
....................             bit_set(PortC,u+1); 
004B:  MOVLW  01
004C:  ADDWF  25,W
004D:  MOVWF  26
004E:  MOVLW  01
004F:  MOVWF  20
0050:  MOVF   26,W
0051:  MOVWF  21
0052:  BTFSC  03.2
0053:  GOTO   057
0054:  LSLF   20,F
0055:  DECFSZ 21,F
0056:  GOTO   054
0057:  MOVF   20,W
0058:  IORWF  0E,F
....................             bit_clear(PortC,u+2); 
0059:  MOVLW  02
005A:  ADDWF  25,W
005B:  MOVWF  26
005C:  MOVLW  01
005D:  MOVWF  20
005E:  MOVF   26,W
005F:  MOVWF  21
0060:  BTFSC  03.2
0061:  GOTO   065
0062:  LSLF   20,F
0063:  DECFSZ 21,F
0064:  GOTO   062
0065:  MOVF   20,W
0066:  XORLW  FF
0067:  ANDWF  0E,F
....................              
....................       i_ant = bit_test(PortA,0); 
0068:  BCF    24.0
0069:  BTFSC  0C.0
006A:  BSF    24.0
....................       j_ant = bit_test(PortA,1); 
006B:  BCF    24.1
006C:  BTFSC  0C.1
006D:  BSF    24.1
....................       k_ant = bit_test(PortA,2); 
006E:  BCF    24.2
006F:  BTFSC  0C.2
0070:  BSF    24.2
....................          } 
0071:  DECF   25,F
0072:  GOTO   048
....................       } 
....................    } 
....................     
....................    return 0; 
0073:  MOVLW  00
0074:  MOVWF  21
.................... } 
0075:  MOVLP  00
0076:  GOTO   0B4 (RETURN)
....................  
.................... int main(void) { 
0077:  CLRF   05
0078:  CLRF   04
0079:  MOVLW  1F
007A:  ANDWF  03,F
007B:  MOVLW  F4
007C:  MOVLB  01
007D:  MOVWF  19
007E:  MOVF   1A,W
007F:  MOVLB  00
0080:  BCF    24.0
0081:  BCF    24.1
0082:  BCF    24.2
0083:  BCF    24.3
0084:  BCF    24.4
0085:  BCF    24.5
0086:  MOVLB  03
0087:  CLRF   0C
0088:  CLRF   0E
0089:  MOVLB  02
008A:  CLRF   12
008B:  CLRF   11
008C:  CLRF   14
008D:  CLRF   13
.................... // Se definen los puertos como entradas o salidas 
....................    set_tris_C(0); 
008E:  MOVLW  00
008F:  MOVLB  01
0090:  MOVWF  0E
....................    set_tris_A(1); 
0091:  MOVLW  01
0092:  MOVWF  0C
....................    PortA = 1; 
0093:  MOVLB  00
0094:  MOVWF  0C
....................    PortC = 0; 
0095:  CLRF   0E
....................    bit_set(PortC,0); 
0096:  BSF    0E.0
....................     
....................    for(;;) { 
....................       if(bit_test(PortA,0) == True && i_ant == False) { 
0097:  BTFSS  0C.0
0098:  GOTO   09D
0099:  BTFSC  24.0
009A:  GOTO   09D
....................          motorSelector = !motorSelector; 
009B:  MOVLW  08
009C:  XORWF  24,F
....................       } 
....................       if(bit_test(PortA,1) == True && j_ant == False) { 
009D:  BTFSS  0C.1
009E:  GOTO   0A3
009F:  BTFSC  24.1
00A0:  GOTO   0A3
....................          Sentido = !Sentido; 
00A1:  MOVLW  10
00A2:  XORWF  24,F
....................       } 
....................       if(bit_test(PortA,2) == True && k_ant == False) { 
00A3:  BTFSS  0C.2
00A4:  GOTO   0A9
00A5:  BTFSC  24.2
00A6:  GOTO   0A9
....................          intensidad = !intensidad; 
00A7:  MOVLW  20
00A8:  XORWF  24,F
....................       }       
....................       i_ant = bit_test(PortA,0); 
00A9:  BCF    24.0
00AA:  BTFSC  0C.0
00AB:  BSF    24.0
....................       j_ant = bit_test(PortA,1); 
00AC:  BCF    24.1
00AD:  BTFSC  0C.1
00AE:  BSF    24.1
....................       k_ant = bit_test(PortA,2); 
00AF:  BCF    24.2
00B0:  BTFSC  0C.2
00B1:  BSF    24.2
....................       DC(); 
00B2:  GOTO   003
....................       BiStr(); 
00B3:  GOTO   012
....................    }    
00B4:  GOTO   097
....................    return (0); 
00B5:  MOVLW  00
00B6:  MOVWF  21
.................... } 
00B7:  SLEEP

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
